'use strict';

// src/error.ts
var TaskDestroyedException = class extends Error {
};

// src/Task.ts
var TaskState = /* @__PURE__ */ ((TaskState2) => {
  TaskState2["PENDING"] = "pending";
  TaskState2["RESOLVED"] = "resolved";
  TaskState2["REJECTED"] = "rejected";
  return TaskState2;
})(TaskState || {});
var Task = class {
  constructor(immediatelyResolveValue) {
    this._state = "pending" /* PENDING */;
    this._promise = new Promise((_resolve, _reject) => {
      this.resolve = function resolve(...args) {
        this._state = "resolved" /* RESOLVED */;
        _resolve(...args);
      };
      this.reject = function reject(...args) {
        this._state = "rejected" /* REJECTED */;
        _reject(...args);
      };
    });
    if (arguments.length > 0) {
      this.resolve(immediatelyResolveValue);
    }
    this._promise.then((value) => {
      this._resolvedValue = value;
    }).catch((err) => {
      this._rejectedValue = err;
    });
  }
  destructor() {
    this.reject(new TaskDestroyedException("Object already destroyed"));
  }
  then(onfulfilled, onrejected) {
    return this._promise.then(onfulfilled).catch(onrejected);
  }
  catch(onrejected) {
    return this._promise.catch(onrejected);
  }
  finally(onfinally) {
    return this._promise.finally(onfinally);
  }
  get state() {
    return this._state;
  }
  resolvedValue() {
    return this._resolvedValue;
  }
  rejectedValue() {
    return this._rejectedValue;
  }
  get [Symbol.toStringTag]() {
    return Task.name;
  }
};

// src/TaskMap.ts
var TaskMap = class extends Map {
  delete(key) {
    if (this.has(key)) {
      const target = this.get(key);
      target.destructor();
      return super.delete(key);
    }
    return false;
  }
  set(key, value) {
    this.delete(key);
    return super.set(key, value);
  }
  clear() {
    for (const key of this.keys()) {
      this.delete(key);
    }
    super.clear();
  }
};

// src/SlidingTaskMap.ts
var SlidingTaskMap = class extends TaskMap {
  constructor(windowSize, ttl) {
    super();
    this.windowSize = windowSize;
    this.ttl = ttl;
    this.keysByTime = [];
    this.ttlMap = /* @__PURE__ */ new Map();
    if (windowSize < 1 || isNaN(windowSize)) {
      throw new TypeError(`windowSize cannot be less than 1!`);
    }
    this.windowSize = Number(windowSize);
    if (ttl !== void 0) {
      if (isNaN(ttl) || ttl < 1) {
        throw new TypeError(`ttl cannot be less than 1!`);
      } else {
        this.ttl = Number(ttl);
      }
    }
  }
  clearTimeout(key) {
    if (this.ttlMap.has(key)) {
      clearTimeout(this.ttlMap.get(key));
      this.ttlMap.delete(key);
    }
  }
  setTimeout(key, customTTL) {
    const ttl = Number(customTTL ?? this.ttl);
    if (ttl > 0) {
      const timeoutId = setTimeout(() => {
        this.delete(key);
      }, ttl);
      this.ttlMap.set(key, timeoutId);
    }
  }
  set(key, value, customTTL) {
    if (this.has(key)) {
      super.set(key, value);
    } else {
      if (this.size + 1 > this.windowSize) {
        this.shift();
      }
      this.keysByTime.push(key);
      super.set(key, value);
    }
    this.setTimeout(key, customTTL);
    return this;
  }
  delete(key) {
    const didDelete = super.delete(key);
    if (didDelete) {
      this.clearTimeout(key);
      const deleteIndex = this.keysByTime.indexOf(key);
      this.keysByTime.splice(deleteIndex, 1);
    }
    return didDelete;
  }
  clear() {
    super.clear();
    this.keysByTime.length = 0;
    this.ttlMap.clear();
  }
  pop() {
    if (this.keysByTime.length === 0) {
      return false;
    }
    const key = this.keysByTime[this.keysByTime.length - 1];
    return this.delete(key);
  }
  shift() {
    if (this.keysByTime.length === 0) {
      return false;
    }
    const key = this.keysByTime[0];
    return this.delete(key);
  }
};

// src/TaskQueue.ts
var TaskQueue = class {
  constructor(queueSize) {
    this._waitingQueue = [];
    this._unlockQueue = [];
    this._processingCount = 0;
    this._queueSize = Math.max(Number(queueSize), 1);
  }
  async _internalSync() {
    if (this._processingCount >= this._queueSize) {
      const waitForUnlockTask = new Task();
      this._unlockQueue.push(waitForUnlockTask);
      await waitForUnlockTask;
    }
    const task = this._waitingQueue.shift();
    if (task) {
      await task.resolver();
    }
  }
  async clear() {
    this._waitingQueue.forEach((item) => item.task.reject(new TaskDestroyedException()));
    this._unlockQueue.forEach((item) => item.reject(new TaskDestroyedException()));
    this._unlockQueue.length = 0;
    this._waitingQueue.length = 0;
    this._processingCount = 0;
  }
  async execute(fn) {
    const task = new Task();
    this._waitingQueue.push({
      task,
      resolver: async () => {
        this._processingCount++;
        const cleanup = () => {
          this._processingCount--;
          const unlockTask = this._unlockQueue.shift();
          unlockTask?.resolve();
        };
        return fn().then((res) => {
          cleanup();
          task.resolve(res);
        }).catch((e) => {
          cleanup();
          task.reject(e);
        });
      }
    });
    this._internalSync().catch(() => {
    });
    return task;
  }
  getStats() {
    return {
      processingCount: this._processingCount,
      waitingCount: this._waitingQueue.length
    };
  }
};

exports.SlidingTaskMap = SlidingTaskMap;
exports.Task = Task;
exports.TaskDestroyedException = TaskDestroyedException;
exports.TaskMap = TaskMap;
exports.TaskQueue = TaskQueue;
exports.TaskState = TaskState;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.cjs.map