{"version":3,"sources":["../src/error.ts","../src/Task.ts","../src/TaskMap.ts","../src/SlidingTaskMap.ts","../src/TaskQueue.ts"],"names":["TaskState"],"mappings":"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","sourcesContent":["export class TaskDestroyedException extends Error {}\n","import type { Deletable } from './types';\nimport { TaskDestroyedException } from './error';\n\nexport enum TaskState {\n  PENDING = 'pending',\n  RESOLVED = 'resolved',\n  REJECTED = 'rejected'\n}\n\nexport class Task<T, E = any> implements Promise<T>, Deletable {\n  private _promise: Promise<T>;\n  private _state: TaskState = TaskState.PENDING\n  private _resolvedValue: Readonly<T> | undefined\n  private _rejectedValue: E | undefined\n\n  public resolve!: (value: T | PromiseLike<T>) => void;\n  public reject!: (reason?: E) => void;\n\n  constructor(immediatelyResolveValue?: T) {\n    this._promise = new Promise<T>((_resolve, _reject) => {\n      this.resolve = function resolve(...args) {\n        this._state = TaskState.RESOLVED\n        _resolve(...args);\n      }\n      this.reject = function reject(...args) {\n        this._state = TaskState.REJECTED\n        _reject(...args);\n      }\n    });\n\n    if (arguments.length > 0) {\n      this.resolve(immediatelyResolveValue as T);\n    }\n\n    this._promise.then(value => {\n      this._resolvedValue = value\n    }).catch((err) => {\n      /* Prevent \"UnhandledPromiseRejectionWarning\" */\n      this._rejectedValue = err\n    });\n  }\n\n  destructor(): void {\n    this.reject(new TaskDestroyedException('Object already destroyed') as E);\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => PromiseLike<TResult1> | TResult1) | undefined | null,\n    onrejected?: ((reason: any) => PromiseLike<TResult2> | TResult2) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled).catch(onrejected);\n  }\n\n  catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n  ): Promise<T | TResult> {\n    return this._promise.catch(onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this._promise.finally(onfinally);\n  }\n\n  get state(): TaskState {\n    return this._state\n  }\n\n  resolvedValue(): Readonly<T> | undefined {\n    return this._resolvedValue\n  }\n\n  rejectedValue(): E | undefined {\n    return this._rejectedValue\n  }\n\n  get [Symbol.toStringTag]() {\n    return Task.name\n  }\n}\n","import type { Deletable } from './types';\n\nexport class TaskMap<K, V extends Deletable> extends Map<K, V> {\n  delete(key: K): boolean {\n    if (this.has(key)) {\n      const target = this.get(key)!;\n      target.destructor();\n      return super.delete(key);\n    }\n    return false;\n  }\n\n  set(key: K, value: V): this {\n    this.delete(key);\n\n    return super.set(key, value);\n  }\n\n  clear(): void {\n    for (const key of this.keys()) {\n      this.delete(key);\n    }\n\n    super.clear();\n  }\n}\n","import type { Deletable } from './types';\nimport { TaskMap } from './TaskMap';\n\nexport class SlidingTaskMap<K, V extends Deletable> extends TaskMap<K, V> {\n  private readonly keysByTime: K[] = [];\n  private readonly ttlMap: Map<K, NodeJS.Timeout> = new Map();\n\n  constructor(private readonly windowSize: number, private readonly ttl?: number) {\n    super();\n\n    if (windowSize < 1 || isNaN(windowSize)) {\n      throw new TypeError(`windowSize cannot be less than 1!`);\n    }\n    this.windowSize = Number(windowSize);\n\n    if (ttl !== undefined) {\n      if (isNaN(ttl) || ttl < 1) {\n        throw new TypeError(`ttl cannot be less than 1!`);\n      } else {\n        this.ttl = Number(ttl);\n      }\n    }\n  }\n\n  private clearTimeout(key: K) {\n    if (this.ttlMap.has(key)) {\n      clearTimeout(this.ttlMap.get(key)!);\n      this.ttlMap.delete(key);\n    }\n  }\n\n  private setTimeout(key: K, customTTL?: number) {\n    const ttl = Number(customTTL ?? this.ttl);\n\n    if (ttl > 0) {\n      const timeoutId = setTimeout(() => {\n        this.delete(key);\n      }, ttl);\n\n      this.ttlMap.set(key, timeoutId);\n    }\n  }\n\n  set(key: K, value: V, customTTL?: number): this {\n    if (this.has(key)) {\n      super.set(key, value);\n    } else {\n      if (this.size + 1 > this.windowSize) {\n        this.shift();\n      }\n\n      this.keysByTime.push(key);\n      super.set(key, value);\n    }\n\n    this.setTimeout(key, customTTL);\n    return this;\n  }\n\n  delete(key: K): boolean {\n    const didDelete = super.delete(key);\n    if (didDelete) {\n      this.clearTimeout(key);\n      const deleteIndex = this.keysByTime.indexOf(key);\n      this.keysByTime.splice(deleteIndex, 1);\n    }\n    return didDelete;\n  }\n\n  clear(): void {\n    super.clear();\n    this.keysByTime.length = 0;\n    this.ttlMap.clear();\n  }\n\n  pop(): boolean {\n    if (this.keysByTime.length === 0) {\n      return false;\n    }\n\n    const key = this.keysByTime[this.keysByTime.length - 1];\n    return this.delete(key);\n  }\n\n  shift(): boolean {\n    if (this.keysByTime.length === 0) {\n      return false;\n    }\n\n    const key = this.keysByTime[0];\n    return this.delete(key);\n  }\n}\n","import { Task } from './Task'\nimport { TaskDestroyedException } from './error';\n\ninterface IWaitingTask<T> {\n  task: Task<T>\n  resolver: () => Promise<void>\n}\n\nexport class TaskQueue<T> {\n  private _waitingQueue: Array<IWaitingTask<T>> = []\n  private _unlockQueue: Array<Task<void>> = []\n\n\n  private readonly _queueSize: number\n  private _processingCount = 0\n\n  constructor(queueSize?: number) {\n    this._queueSize = Math.max(Number(queueSize), 1)\n  }\n\n  private async _internalSync() {\n    if (this._processingCount >= this._queueSize) {\n      const waitForUnlockTask = new Task<void>()\n      this._unlockQueue.push(waitForUnlockTask)\n      await waitForUnlockTask\n    }\n\n    const task = this._waitingQueue.shift()\n    if (task) {\n      await task.resolver()\n    }\n  }\n\n  async clear() {\n    this._waitingQueue.forEach(item => item.task.reject(new TaskDestroyedException()))\n    this._unlockQueue.forEach(item => item.reject(new TaskDestroyedException()))\n\n    this._unlockQueue.length = 0\n    this._waitingQueue.length = 0\n    this._processingCount = 0\n  }\n\n  async execute(fn: () => Promise<T>): Promise<T> {\n    const task = new Task<T>()\n    this._waitingQueue.push({\n      task,\n      resolver: async () => {\n        this._processingCount++\n\n        const cleanup = () => {\n          this._processingCount--\n          const unlockTask = this._unlockQueue.shift()\n          unlockTask?.resolve()\n        }\n\n        return fn()\n          .then((res) => {\n            cleanup();\n            task.resolve(res);\n          })\n          .catch(e => {\n            cleanup();\n            task.reject(e);\n          })\n      }\n    })\n\n    this._internalSync().catch(() => {})\n\n    return task\n  }\n\n  getStats() {\n    return {\n      processingCount: this._processingCount,\n      waitingCount: this._waitingQueue.length,\n    }\n  }\n}\n"]}