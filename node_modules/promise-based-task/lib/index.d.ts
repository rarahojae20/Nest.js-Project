interface Deletable {
    destructor: () => void;
}

declare enum TaskState {
    PENDING = "pending",
    RESOLVED = "resolved",
    REJECTED = "rejected"
}
declare class Task<T, E = any> implements Promise<T>, Deletable {
    private _promise;
    private _state;
    private _resolvedValue;
    private _rejectedValue;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: E) => void;
    constructor(immediatelyResolveValue?: T);
    destructor(): void;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => PromiseLike<TResult1> | TResult1) | undefined | null, onrejected?: ((reason: any) => PromiseLike<TResult2> | TResult2) | undefined | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
    get state(): TaskState;
    resolvedValue(): Readonly<T> | undefined;
    rejectedValue(): E | undefined;
    get [Symbol.toStringTag](): string;
}

declare class TaskMap<K, V extends Deletable> extends Map<K, V> {
    delete(key: K): boolean;
    set(key: K, value: V): this;
    clear(): void;
}

declare class SlidingTaskMap<K, V extends Deletable> extends TaskMap<K, V> {
    private readonly windowSize;
    private readonly ttl?;
    private readonly keysByTime;
    private readonly ttlMap;
    constructor(windowSize: number, ttl?: number | undefined);
    private clearTimeout;
    private setTimeout;
    set(key: K, value: V, customTTL?: number): this;
    delete(key: K): boolean;
    clear(): void;
    pop(): boolean;
    shift(): boolean;
}

declare class TaskQueue<T> {
    private _waitingQueue;
    private _unlockQueue;
    private readonly _queueSize;
    private _processingCount;
    constructor(queueSize?: number);
    private _internalSync;
    clear(): Promise<void>;
    execute(fn: () => Promise<T>): Promise<T>;
    getStats(): {
        processingCount: number;
        waitingCount: number;
    };
}

declare class TaskDestroyedException extends Error {
}

export { Deletable, SlidingTaskMap, Task, TaskDestroyedException, TaskMap, TaskQueue, TaskState };
